import _typeof from "@babel/runtime/helpers/typeof";
import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["suggestedTags", "tags", "onAdd", "onRemove", "onGenerate", "onClear", "onValidate", "placeholder", "disabled", "readOnly", "label", "suggestionLabel", "suggestionTooltipMessage", "LabelProps", "error", "hint", "size", "crossIcon", "loading", "appliedValue", "disableOnEnter", "copyTextMessage", "copySuccessIcon", "submitOnSpace", "preventSubmitOnBlur", "hideCopyIcon", "showGenerateTagsButton", "generateTagsButtonLabel", "clearTagsButtonLabel", "alwaysShowSuggestedTags", "getTagLabel", "getTagValue", "getTagIcon", "suggestionsFilter"];
import React, { useState, useMemo, useEffect } from 'react';
import PT from 'prop-types';
import { InfoOutline, CopyOutline } from '@scaleflex/icons';
import SpinnerIcon from '@scaleflex/icons/spinner';
import { intrinsicComponent, objectValues } from '../../utils/functions';
import { Color } from '../../utils/types/palette';
import { lightPalette } from '../../theme/roots/palette';
import Tag from '../tag';
import Label from '../label';
import Tooltip from '../tooltip';
import FormHint from '../form-hint';
import Button from '../button/button.component';
import { propTypes as labelPropTypes } from '../label/label.component';
import { AddTagType, Size } from './types';
import { tagsSuggestionsFilter } from './tag-field.utils';
import { handleCopyIcon } from '../input/input.utils';
import InputStyled from '../input/input.styles';
import Styled from './tag-field.styles';
var TagField = intrinsicComponent(function (_ref, ref) {
  var _ref$suggestedTags = _ref.suggestedTags,
    suggestedTags = _ref$suggestedTags === void 0 ? [] : _ref$suggestedTags,
    _ref$tags = _ref.tags,
    tags = _ref$tags === void 0 ? [] : _ref$tags,
    onAdd = _ref.onAdd,
    onRemove = _ref.onRemove,
    onGenerate = _ref.onGenerate,
    onClear = _ref.onClear,
    onValidate = _ref.onValidate,
    placeholder = _ref.placeholder,
    disabled = _ref.disabled,
    readOnly = _ref.readOnly,
    label = _ref.label,
    suggestionLabel = _ref.suggestionLabel,
    suggestionTooltipMessage = _ref.suggestionTooltipMessage,
    LabelPropsData = _ref.LabelProps,
    _ref$error = _ref.error,
    error = _ref$error === void 0 ? false : _ref$error,
    hint = _ref.hint,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? Size.Md : _ref$size,
    _ref$crossIcon = _ref.crossIcon,
    crossIcon = _ref$crossIcon === void 0 ? true : _ref$crossIcon,
    loading = _ref.loading,
    appliedValue = _ref.appliedValue,
    disableOnEnter = _ref.disableOnEnter,
    _ref$copyTextMessage = _ref.copyTextMessage,
    copyTextMessage = _ref$copyTextMessage === void 0 ? '' : _ref$copyTextMessage,
    copySuccessIcon = _ref.copySuccessIcon,
    submitOnSpace = _ref.submitOnSpace,
    preventSubmitOnBlur = _ref.preventSubmitOnBlur,
    _ref$hideCopyIcon = _ref.hideCopyIcon,
    hideCopyIcon = _ref$hideCopyIcon === void 0 ? false : _ref$hideCopyIcon,
    _ref$showGenerateTags = _ref.showGenerateTagsButton,
    showGenerateTagsButton = _ref$showGenerateTags === void 0 ? false : _ref$showGenerateTags,
    _ref$generateTagsButt = _ref.generateTagsButtonLabel,
    generateTagsButtonLabel = _ref$generateTagsButt === void 0 ? 'Generate tags' : _ref$generateTagsButt,
    _ref$clearTagsButtonL = _ref.clearTagsButtonLabel,
    clearTagsButtonLabel = _ref$clearTagsButtonL === void 0 ? 'Clear all' : _ref$clearTagsButtonL,
    _ref$alwaysShowSugges = _ref.alwaysShowSuggestedTags,
    alwaysShowSuggestedTags = _ref$alwaysShowSugges === void 0 ? false : _ref$alwaysShowSugges,
    _ref$getTagLabel = _ref.getTagLabel,
    getTagLabel = _ref$getTagLabel === void 0 ? function (tag) {
      return tag;
    } : _ref$getTagLabel,
    _ref$getTagValue = _ref.getTagValue,
    getTagValue = _ref$getTagValue === void 0 ? function (tag) {
      return tag;
    } : _ref$getTagValue,
    getTagIcon = _ref.getTagIcon,
    _ref$suggestionsFilte = _ref.suggestionsFilter,
    suggestionsFilter = _ref$suggestionsFilte === void 0 ? tagsSuggestionsFilter : _ref$suggestionsFilte,
    rest = _objectWithoutProperties(_ref, _excluded);
  var _useState = useState(''),
    _useState2 = _slicedToArray(_useState, 2),
    userInput = _useState2[0],
    setUserInput = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    showCopyMessage = _useState4[0],
    setShowCopyMessage = _useState4[1];
  var _useState5 = useState(hint),
    _useState6 = _slicedToArray(_useState5, 2),
    tagsHint = _useState6[0],
    setTagsHint = _useState6[1];
  var _useState7 = useState(error),
    _useState8 = _slicedToArray(_useState7, 2),
    tagsError = _useState8[0],
    setTagsError = _useState8[1];
  var _useState9 = useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    showPlaceholder = _useState10[0],
    setShowPlaceholder = _useState10[1];
  var filteredTags = useMemo(function () {
    return tags.filter(function (tag) {
      return tag;
    });
  }, [tags]);
  var existingLabels = useMemo(function () {
    return filteredTags.map(function (tag) {
      return getTagLabel(tag).toLowerCase();
    });
  }, [filteredTags]);
  var filteredSuggestions = useMemo(function () {
    var filteredItems = suggestedTags === null || suggestedTags === void 0 ? void 0 : suggestedTags.filter(function (suggestion) {
      var _getTagLabel;
      return !(existingLabels !== null && existingLabels !== void 0 && existingLabels.includes((_getTagLabel = getTagLabel(suggestion)) === null || _getTagLabel === void 0 ? void 0 : _getTagLabel.toLowerCase()));
    });
    return suggestionsFilter(filteredItems, userInput, getTagLabel, alwaysShowSuggestedTags);
  }, [userInput, suggestedTags, existingLabels, suggestionsFilter]);
  var handleTagAdd = function handleTagAdd(item, type) {
    if (!item) return;
    var tagLabel = type === AddTagType.UserInput ? item : getTagLabel(item);
    if (!filteredTags.some(function (tag) {
      return getTagLabel(tag).toLowerCase() === tagLabel.toLowerCase();
    })) {
      onAdd(item, type, setUserInput);
    }
  };
  var convertToLower = function convertToLower(value) {
    return value.toLocaleLowerCase();
  };
  var isMatchingSuggestedTag = filteredSuggestions.some(function (item) {
    return convertToLower(getTagLabel(item)) === convertToLower(userInput);
  });
  var handleAddingTag = function handleAddingTag() {
    if (userInput) {
      if (isMatchingSuggestedTag) {
        var nextUserInput = filteredSuggestions.find(function (item) {
          return convertToLower(getTagLabel(item)) === convertToLower(userInput);
        });
        handleTagAdd(nextUserInput, AddTagType.Suggestion);
      } else {
        handleTagAdd(userInput, AddTagType.UserInput);
      }
    }
    setUserInput('');
  };
  var handleTagsValidation = function handleTagsValidation() {
    if (!(userInput !== null && userInput !== void 0 && userInput.length)) return;
    if (typeof onValidate === 'function') {
      var isValid = onValidate(userInput);
      if (typeof isValid === 'string') {
        setTagsHint(isValid);
        setTagsError(true);
        return;
      }
      setTagsHint('');
      setTagsError(false);
      handleAddingTag();
    }
  };
  var handleOnBlur = function handleOnBlur() {
    setShowPlaceholder(false);
    if (preventSubmitOnBlur) return;
    handleTagsValidation();
  };
  var handleUserInputKeyDown = function handleUserInputKeyDown(event) {
    if (event.key === 'Enter' && !disableOnEnter || event.key === ' ' && submitOnSpace) {
      event.preventDefault();
      handleAddingTag();
    } else if (event.key === 'Backspace' && !userInput && (filteredTags === null || filteredTags === void 0 ? void 0 : filteredTags.length) > 0) {
      var index = filteredTags.length - 1;
      onRemove(index, getTagValue(filteredTags[index]), setUserInput, event);
    }
  };
  var handleInputFocus = function handleInputFocus() {
    setShowPlaceholder(true);
  };
  var handleClearAllTags = function handleClearAllTags() {
    if (onClear) {
      onClear();
    }
  };
  useEffect(function () {
    if (!(filteredTags !== null && filteredTags !== void 0 && filteredTags.length)) {
      setShowPlaceholder(true);
    }
  }, [filteredTags]);

  // TODO remove when add clear all button
  useEffect(function () {
    if (typeof appliedValue === 'string' && !appliedValue) {
      setUserInput('');
    }
  }, [appliedValue]);
  useEffect(function () {
    setTimeout(function () {
      return setShowCopyMessage(false);
    }, 2000);
  }, [showCopyMessage]);
  useEffect(function () {
    setTagsError(error);
    setTagsHint(hint);
  }, [error, hint]);
  return /*#__PURE__*/React.createElement(Styled.TagFieldRoot, {
    ref: ref
  }, /*#__PURE__*/React.createElement(Styled.TagInputFieldWrapper, null, label && /*#__PURE__*/React.createElement(Label, _extends({
    error: tagsError
  }, LabelPropsData || {}), label), /*#__PURE__*/React.createElement(Styled.TagFieldWrapper, _extends({
    size: size,
    error: tagsError
  }, rest), /*#__PURE__*/React.createElement(Styled.TagFieldListWrapper, {
    $loading: loading
  }, filteredTags.map(function (tag, index) {
    return /*#__PURE__*/React.createElement(Tag, {
      key: getTagValue(tag),
      tagIndex: index,
      crossIcon: crossIcon,
      startIcon: _typeof(getTagIcon === null || getTagIcon === void 0 ? void 0 : getTagIcon(tag)) === 'object' ? getTagIcon === null || getTagIcon === void 0 ? void 0 : getTagIcon(tag) : null,
      size: size,
      onRemove: disabled || readOnly || loading ? undefined : function (_tagIndex, event) {
        return onRemove(index, getTagValue(tag), setUserInput, event);
      },
      style: {
        margin: '0px 8px 8px 0px'
      }
    }, getTagLabel(tag));
  }), loading ? /*#__PURE__*/React.createElement(Styled.TagFieldLoader, null, /*#__PURE__*/React.createElement(SpinnerIcon, {
    size: 16,
    color: lightPalette[Color.IconsPrimary]
  })) : /*#__PURE__*/React.createElement(Styled.TagFieldInputWrapper, {
    size: size
  }, /*#__PURE__*/React.createElement(Styled.TagFieldInput, {
    value: userInput,
    type: "text",
    autoComplete: "off",
    placeholder: showPlaceholder ? placeholder : '',
    onChange: function onChange(ev) {
      return setUserInput(ev.target.value);
    },
    onKeyDown: handleUserInputKeyDown,
    onBlur: handleOnBlur,
    onFocus: handleInputFocus,
    readOnly: readOnly,
    disabled: disabled
  }))), /*#__PURE__*/React.createElement(Styled.TagFieldBottom, null, /*#__PURE__*/React.createElement(Styled.TagFieldButtonsWrapper, null, showGenerateTagsButton && /*#__PURE__*/React.createElement(Button, {
    color: "link-primary",
    size: size,
    onClick: onGenerate
  }, generateTagsButtonLabel), /*#__PURE__*/React.createElement(Button, {
    color: "link-secondary",
    size: size === Size.Md ? Size.Sm : 'xs',
    onClick: handleClearAllTags
  }, clearTagsButtonLabel)), !hideCopyIcon && /*#__PURE__*/React.createElement(Styled.TagFieldCopyIcon, {
    onClick: function onClick() {
      return handleCopyIcon(userInput, setShowCopyMessage);
    }
  }, /*#__PURE__*/React.createElement(CopyOutline, {
    size: 16,
    color: lightPalette[Color.IconsPrimary]
  })), showCopyMessage && /*#__PURE__*/React.createElement(InputStyled.NotificationBox, {
    size: size,
    style: {
      bottom: size === Size.Md ? 148 : 140
    }
  }, /*#__PURE__*/React.createElement(InputStyled.NotificationIcon, null, copySuccessIcon), /*#__PURE__*/React.createElement(InputStyled.NotificationText, null, copyTextMessage)))), tagsHint && /*#__PURE__*/React.createElement(FormHint, {
    error: tagsError
  }, tagsHint)), filteredSuggestions.length > 0 && /*#__PURE__*/React.createElement(Styled.TagFieldSuggestionWrapper, null, /*#__PURE__*/React.createElement(Styled.TagFieldSuggestionLabel, null, suggestionLabel || /*#__PURE__*/React.createElement("span", null, "Suggested Tags"), suggestionTooltipMessage && /*#__PURE__*/React.createElement(Tooltip, {
    title: suggestionTooltipMessage,
    size: Size.Sm,
    arrow: true,
    position: "right"
  }, /*#__PURE__*/React.createElement(Styled.TagFieldSuggestionIcon, null, /*#__PURE__*/React.createElement(InfoOutline, {
    size: 12,
    color: lightPalette[Color.IconsSecondary]
  })))), /*#__PURE__*/React.createElement(Styled.TagFieldSuggestionWrapperList, null, filteredSuggestions.map(function (suggestion) {
    return /*#__PURE__*/React.createElement(Tag, {
      key: getTagValue(suggestion),
      type: "suggested",
      crossIcon: false,
      onSelect: function onSelect() {
        handleTagAdd(suggestion, AddTagType.Suggestion);
        setUserInput('');
      },
      startIcon: _typeof(getTagIcon === null || getTagIcon === void 0 ? void 0 : getTagIcon(suggestion)) === 'object' ? getTagIcon === null || getTagIcon === void 0 ? void 0 : getTagIcon(suggestion) : null,
      style: {
        margin: '0 8px 8px 0'
      },
      size: size
    }, getTagLabel(suggestion));
  }))));
});
TagField.defaultProps = {
  tags: [],
  suggestedTags: [],
  placeholder: 'Add a tag (separate by pressing enter)',
  disabled: false,
  readOnly: false,
  size: Size.Md
};
TagField.propTypes = {
  tags: PT.arrayOf(PT.oneOfType([PT.string, PT.object, PT.node])).isRequired,
  suggestedTags: PT.arrayOf(PT.oneOfType([PT.string, PT.object])),
  LabelProps: PT.exact(labelPropTypes),
  onAdd: PT.func.isRequired,
  onRemove: PT.func.isRequired,
  onGenerate: PT.func,
  onClear: PT.func.isRequired,
  onValidate: PT.func,
  placeholder: PT.string,
  appliedValue: PT.string,
  readOnly: PT.bool,
  disabled: PT.bool,
  label: PT.node,
  error: PT.bool,
  hint: PT.node,
  loading: PT.bool,
  disableOnEnter: PT.bool,
  size: PT.oneOf(objectValues(Size)),
  hideCopyIcon: PT.bool,
  alwaysShowSuggestedTags: PT.bool,
  getTagValue: PT.func,
  getTagLabel: PT.func,
  getTagIcon: PT.func,
  submitOnSpace: PT.bool,
  preventSubmitOnBlur: PT.bool,
  showGenerateTagsButton: PT.bool,
  generateTagsButtonLabel: PT.string,
  clearTagsButtonLabel: PT.string,
  suggestionsFilter: PT.func,
  suggestionLabel: PT.node,
  suggestionTooltipMessage: PT.string,
  copySuccessIcon: PT.oneOfType([PT.node, PT.func]),
  copyTextMessage: PT.string
};
export default TagField;