import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "position", "popperOptions", "arrow", "warning", "enableUnderlayingEvent", "popperWrapperStyles", "enableHover", "enterDelay", "leaveDelay", "stayOpen", "title", "tooltipProps"];
import React, { useState, useRef, useEffect } from 'react';
import PT from 'prop-types';
import { intrinsicComponent, objectValues } from '../../utils/functions';
import { Size } from './types';
import { Position, Strategy } from '../popper/types';
import Styled from './tooltip.styles';
import Popper from '../popper';
var Tooltip = intrinsicComponent(function (_ref, ref) {
  var children = _ref.children,
    _ref$position = _ref.position,
    position = _ref$position === void 0 ? Position.Top : _ref$position,
    popperOptions = _ref.popperOptions,
    _ref$arrow = _ref.arrow,
    arrow = _ref$arrow === void 0 ? true : _ref$arrow,
    warning = _ref.warning,
    enableUnderlayingEvent = _ref.enableUnderlayingEvent,
    _ref$popperWrapperSty = _ref.popperWrapperStyles,
    popperWrapperStyles = _ref$popperWrapperSty === void 0 ? {} : _ref$popperWrapperSty,
    enableHover = _ref.enableHover,
    _ref$enterDelay = _ref.enterDelay,
    enterDelay = _ref$enterDelay === void 0 ? 0 : _ref$enterDelay,
    _ref$leaveDelay = _ref.leaveDelay,
    leaveDelay = _ref$leaveDelay === void 0 ? 0 : _ref$leaveDelay,
    stayOpen = _ref.stayOpen,
    title = _ref.title,
    tooltipProps = _ref.tooltipProps,
    rest = _objectWithoutProperties(_ref, _excluded);
  var _useState = useState(true),
    _useState2 = _slicedToArray(_useState, 2),
    isHovering = _useState2[0],
    setIsHovering = _useState2[1];
  var _useState3 = useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    anchorEl = _useState4[0],
    setAnchorEl = _useState4[1];
  var open = Boolean(anchorEl);
  var tooltipRef = useRef(null);
  var handleMouseEnter = function handleMouseEnter(event) {
    var onMouseEnter = children.props.onMouseEnter;
    var currentTarget = event.currentTarget;
    setTimeout(function () {
      setAnchorEl(currentTarget);
    }, enterDelay);
    if (typeof onMouseEnter === 'function') {
      onMouseEnter(event);
    }
  };
  var closeTooltip = function closeTooltip() {
    if (!stayOpen) {
      setAnchorEl(null);
    }
  };
  useEffect(function () {
    closeTooltip();
  }, [isHovering]);
  var handleMouseLeave = function handleMouseLeave(event) {
    var onMouseLeave = children.props.onMouseLeave;
    if (enableHover) {
      setTimeout(function () {
        if (!isHovering) {
          closeTooltip();
        }
      }, 200);
    } else {
      setTimeout(function () {
        closeTooltip();
      }, leaveDelay);
    }
    if (typeof onMouseLeave === 'function') {
      onMouseLeave(event);
    }
  };
  var handleEnteringTooltip = function handleEnteringTooltip() {
    if (enableHover) {
      setIsHovering(true);
    }
  };
  var handleLeavingTooltip = function handleLeavingTooltip() {
    if (enableHover) {
      setTimeout(function () {
        setIsHovering(false);
      }, leaveDelay);
    }
  };
  var render = function render() {
    return /*#__PURE__*/React.createElement(Popper, {
      ref: tooltipRef,
      position: position,
      anchorEl: anchorEl,
      warning: warning,
      open: anchorEl ? open : false,
      popperOptions: popperOptions,
      arrow: arrow,
      enableUnderlayingEvent: enableUnderlayingEvent,
      wrapperStyles: popperWrapperStyles
    }, /*#__PURE__*/React.createElement(Styled.TooltipContainer, _extends({}, rest, {
      open: open,
      onMouseEnter: handleEnteringTooltip,
      onMouseLeave: handleLeavingTooltip
    }), /*#__PURE__*/React.createElement(Styled.Tooltip, _extends({
      warning: warning
    }, tooltipProps), title)));
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.cloneElement(children, {
    ref: ref,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), render());
});
Tooltip.defaultProps = {
  position: Position.Top,
  size: Size.Sm,
  arrow: true,
  warning: false,
  enterDelay: 0,
  leaveDelay: 0
};
Tooltip.propTypes = {
  position: PT.oneOf(objectValues(Position)),
  size: PT.oneOf(objectValues(Size)),
  title: PT.node,
  children: PT.element,
  arrow: PT.bool,
  warning: PT.bool,
  enterDelay: PT.number,
  leaveDelay: PT.number,
  stayOpen: PT.bool,
  popperOptions: PT.shape({
    modifiers: PT.arrayOf(PT.shape({
      data: PT.object,
      effect: PT.func,
      enabled: PT.bool,
      fn: PT.func,
      name: PT.any.isRequired,
      options: PT.object,
      phase: PT.oneOf(['afterMain', 'afterRead', 'afterWrite', 'beforeMain', 'beforeRead', 'beforeWrite', 'main', 'read', 'write']),
      requires: PT.arrayOf(PT.string),
      requiresIfExists: PT.arrayOf(PT.string)
    })),
    onFirstUpdate: PT.func,
    placement: PT.oneOf(objectValues(Position)),
    strategy: PT.oneOf(objectValues(Strategy))
  }),
  enableUnderlayingEvent: PT.bool,
  popperWrapperStyles: PT.object,
  tooltipProps: PT.object,
  enableHover: PT.bool
};
export default Tooltip;