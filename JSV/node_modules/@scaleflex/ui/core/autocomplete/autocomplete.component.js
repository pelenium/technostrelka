import _extends from "@babel/runtime/helpers/extends";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "MenuProps", "LabelProps", "InputProps", "error", "label", "hint", "value", "noOptionsText", "focusOnOpen", "onChange", "onOpen", "onClose", "getOptionDisabled", "getOptionValue", "getOptionLabel", "multiple", "size", "disabled", "scroll", "readOnly", "options", "placeholder", "fullWidth", "sortAlphabetically", "submitOnBlur"];
import React, { useRef, useEffect, useState } from 'react';
import PT from 'prop-types';
import Tick from '@scaleflex/icons/tick';
import { intrinsicComponent, objectValues } from '../../utils/functions';
import { propTypes as labelPropTypes } from '../label/label.component';
import { propTypes as inputPropTypes } from '../input/input.component';
import Label from '../label';
import FormHint from '../form-hint';
import ArrowTick from '../arrow-tick';
import Input from '../input';
import Menu from '../menu';
import Tag from '../tag';
import MenuItem, { MenuItemActions } from '../menu-item';
import { InputSize } from '../../utils/types';
import { Size } from '../menu-item/types';
import Styled from './autocomplete.styles';
var Autocomplete = intrinsicComponent(function (_ref, ref) {
  var children = _ref.children,
    MenuProps = _ref.MenuProps,
    LabelPropsData = _ref.LabelProps,
    InputPropsData = _ref.InputProps,
    error = _ref.error,
    label = _ref.label,
    hint = _ref.hint,
    value = _ref.value,
    _ref$noOptionsText = _ref.noOptionsText,
    noOptionsText = _ref$noOptionsText === void 0 ? 'No options' : _ref$noOptionsText,
    focusOnOpen = _ref.focusOnOpen,
    onChange = _ref.onChange,
    onOpen = _ref.onOpen,
    onClose = _ref.onClose,
    _ref$getOptionDisable = _ref.getOptionDisabled,
    getOptionDisabled = _ref$getOptionDisable === void 0 ? function () {
      return false;
    } : _ref$getOptionDisable,
    getOptionValue = _ref.getOptionValue,
    getOptionLabel = _ref.getOptionLabel,
    multiple = _ref.multiple,
    size = _ref.size,
    disabled = _ref.disabled,
    scroll = _ref.scroll,
    readOnly = _ref.readOnly,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? [] : _ref$options,
    placeholder = _ref.placeholder,
    fullWidth = _ref.fullWidth,
    sortAlphabetically = _ref.sortAlphabetically,
    submitOnBlur = _ref.submitOnBlur,
    rest = _objectWithoutProperties(_ref, _excluded);
  var inputRef = useRef(null);
  var getNextOptionLabel = function getNextOptionLabel(option) {
    if (getOptionLabel) {
      return getOptionLabel(option);
    }
    return option.label;
  };
  var getNextOptionValue = function getNextOptionValue(option) {
    if (getOptionValue) {
      return getOptionValue(option);
    }
    return option.id;
  };
  var getFilteredItems = function getFilteredItems(items, callBackFun) {
    var filteredItems = [];
    items.forEach(function (item, index, array) {
      return callBackFun(item, index, array) && filteredItems.push(item);
    });
    return filteredItems;
  };
  var isObjectOptions = _typeof(options[0]) === 'object';
  var getSortedOptions = function getSortedOptions() {
    if (isObjectOptions && sortAlphabetically) {
      return options.sort(function (a, b) {
        return getNextOptionLabel(a).localeCompare(getNextOptionLabel(b));
      });
    }
    if (sortAlphabetically) {
      return options.sort();
    }
    return options;
  };
  var removedDuplicatedOptions = getFilteredItems(getSortedOptions(), function (option, index, array) {
    if (array.findIndex(function (item) {
      return getNextOptionLabel(item) === getNextOptionLabel(option);
    }) === index) {
      return true;
    }
    return false;
  });
  var _useState = useState(multiple ? [] : ''),
    _useState2 = _slicedToArray(_useState, 2),
    selected = _useState2[0],
    setSelected = _useState2[1];
  var _useState3 = useState(removedDuplicatedOptions),
    _useState4 = _slicedToArray(_useState3, 2),
    filteredOptions = _useState4[0],
    setFilteredOptions = _useState4[1];
  var _useState5 = useState(undefined),
    _useState6 = _slicedToArray(_useState5, 2),
    anchorEl = _useState6[0],
    setAnchorEl = _useState6[1];
  var _useState7 = useState(-1),
    _useState8 = _slicedToArray(_useState7, 2),
    currentItemIndex = _useState8[0],
    setCurrentItemIndex = _useState8[1];
  var _useState9 = useState(''),
    _useState10 = _slicedToArray(_useState9, 2),
    renderedValue = _useState10[0],
    setRenderedValue = _useState10[1];
  var _useState11 = useState([]),
    _useState12 = _slicedToArray(_useState11, 2),
    selectedItemsIndex = _useState12[0],
    setSelectedIemsIndex = _useState12[1];
  var open = Boolean(anchorEl);
  var isItemSelected = (multiple ? (selected || []).length > 0 : !!selected) || selectedItemsIndex.length > 0;
  var hasDuplicatedLabels = removedDuplicatedOptions.length !== options.length;
  var convertToLower = function convertToLower(val) {
    return (val || '').toString().toLowerCase();
  };
  var onBlurHandler = function onBlurHandler() {
    if (submitOnBlur) {
      submitOnBlur();
    }
    setAnchorEl(undefined);
  };
  var handleOnChange = function handleOnChange(event, val, id) {
    if (multiple) {
      if (onChange) {
        if (isObjectOptions && id) {
          onChange(event, [].concat(_toConsumableArray(selected), _toConsumableArray(id)));
        } else if (!isObjectOptions) {
          onChange(event, [].concat(_toConsumableArray(selected), _toConsumableArray(val)));
        }
      }
    } else {
      if (onChange) {
        if (isObjectOptions && id) {
          onChange(event, id);
        } else if (!isObjectOptions) {
          onChange(event, val);
        }
      }
      setSelected('');
      setCurrentItemIndex(-1);
    }
  };
  var handleOnRemoveItem = function handleOnRemoveItem(event, itemIndex, index) {
    event.stopPropagation();
    var updatedSelectedItems = Array.isArray(selected) ? selected.filter(function (_, nextIndex) {
      return nextIndex !== index;
    }) : '';
    var updatedSelectedIndex = selectedItemsIndex.filter(function (nextIndex) {
      return nextIndex !== itemIndex;
    });
    setSelected(updatedSelectedItems);
    setSelectedIemsIndex(updatedSelectedIndex);
    if (onChange) {
      if (isObjectOptions) {
        onChange(event, _toConsumableArray(updatedSelectedItems));
      } else if (!multiple) {
        onChange(event, [].concat(_toConsumableArray(updatedSelectedItems), ['']));
      }
    }
    if (submitOnBlur) {
      submitOnBlur();
    }
  };
  var handleOpenClick = function handleOpenClick(event) {
    setAnchorEl(inputRef.current);
    if (onOpen) {
      onOpen(event);
    }
  };
  var handleCloseClick = function handleCloseClick(event) {
    setAnchorEl(undefined);
    setCurrentItemIndex(-1);
    if (onClose) {
      onClose(event);
    }
  };
  var handleClearIconClick = function handleClearIconClick(event) {
    event === null || event === void 0 ? void 0 : event.stopPropagation();
    if (multiple) {
      if (onChange) {
        onChange(event, []);
      }
      setSelected([]);
    } else {
      if (onChange) {
        onChange(event, '');
      }
      setSelected('');
    }
    setCurrentItemIndex(-1);
    setSelectedIemsIndex([]);
  };
  var handleSelectedItem = function handleSelectedItem(event, item, id, index) {
    // make sure this item isn't already selected
    if (!multiple && (selected !== item || isObjectOptions && selected !== id)) {
      handleOnChange(event, item, id);
      if (isObjectOptions) {
        var nextOptionId = getNextOptionValue(removedDuplicatedOptions[index]);
        setSelectedIemsIndex([index]);
        setSelected(nextOptionId);
      } else {
        setSelected(item);
      }
    } else if (multiple) {
      if (Array.isArray(selected) && (selected.includes(item) || isObjectOptions && selected.includes(id) && selectedItemsIndex.includes(index))) {
        var updatedSelectedItems = selected;
        if (isObjectOptions) {
          var removedIndex = selected.findIndex(function (selectedId) {
            return selectedId === id;
          });
          if (removedIndex !== -1) {
            updatedSelectedItems.splice(removedIndex, 1);
          }
        } else {
          updatedSelectedItems = selected.filter(function (selectedItem) {
            return selectedItem !== item;
          });
        }
        var updatedSelectedIndex = selectedItemsIndex.filter(function (nextIndex) {
          return nextIndex !== index;
        });
        setSelected(updatedSelectedItems);
        setSelectedIemsIndex(updatedSelectedIndex);
        if (onChange) {
          onChange(event, _toConsumableArray(updatedSelectedItems));
        }
      } else if (isObjectOptions) {
        handleOnChange(event, null, [id]);
        setSelectedIemsIndex(function (prev) {
          return [].concat(_toConsumableArray(prev), [index]);
        });
        setSelected(function (prev) {
          return [].concat(_toConsumableArray(prev), [id]);
        });
      } else {
        handleOnChange(event, [item], null);
        setSelected(function (prev) {
          return [].concat(_toConsumableArray(prev), [item]);
        });
        setSelectedIemsIndex(function (prev) {
          return [].concat(_toConsumableArray(prev), [index]);
        });
      }
    }
    setRenderedValue('');
    handleCloseClick(event);
  };
  var handleMenuItemClick = function handleMenuItemClick(event, item, index, id) {
    // menu item shouldn't be clickable if it's disabled or = 'No options'
    if (item === noOptionsText || getOptionDisabled && getOptionDisabled(item, index)) {
      return null;
    }
    return handleSelectedItem(event, item, id, index);
  };
  var getObjectOptionLabel = function getObjectOptionLabel(optionValue, optionIndex) {
    var selectedOptionIndex = removedDuplicatedOptions.findIndex(function (option, index) {
      return getNextOptionValue(option) === optionValue && index === optionIndex;
    });
    return (getOptionLabel ? getOptionLabel(removedDuplicatedOptions[selectedOptionIndex]) : removedDuplicatedOptions[selectedOptionIndex]) || optionValue;
  };
  var getValue = function getValue() {
    if (isObjectOptions && !multiple && selected.length > 0) return getObjectOptionLabel(value, selectedItemsIndex[0]);
    if (!isObjectOptions && !multiple) return value;
    return renderedValue;
  };
  var handleInputChange = function handleInputChange(event) {
    var inputValue = event.currentTarget.value;
    setRenderedValue(inputValue);
    if (!multiple) handleOnChange(event, [inputValue], null);
    setAnchorEl(inputRef.current);
  };
  var getOptionIndex = function getOptionIndex(option) {
    var optionIndex = -1;
    if (isObjectOptions) {
      var optionObject = Object.entries(removedDuplicatedOptions).find(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          _ = _ref3[0],
          optObject = _ref3[1];
        return getNextOptionLabel(optObject) === option;
      });
      if (optionObject) {
        optionIndex = Number(optionObject[0]);
      }
    } else {
      optionIndex = removedDuplicatedOptions.indexOf(option);
    }
    return optionIndex;
  };
  var isMenuItemsAvailable = function isMenuItemsAvailable() {
    var validMenuItems = getFilteredItems(filteredOptions, function (option) {
      var filteredOptionLabel = getNextOptionLabel(option);
      var filteredOptionItem = isObjectOptions ? filteredOptionLabel : option;
      var filteredOptionIndex = getOptionIndex(filteredOptionItem);
      if (option !== noOptionsText && getOptionDisabled && !getOptionDisabled(filteredOptionItem, filteredOptionIndex)) return true;
      return false;
    });
    return !!validMenuItems.length;
  };
  var getNextAvailableOption = function getNextAvailableOption(currentIndex, direction) {
    if (!isMenuItemsAvailable()) return;
    while (currentIndex !== currentItemIndex) {
      var filteredItemLabel = getNextOptionLabel(filteredOptions[currentIndex]);
      var selectedOption = isObjectOptions ? filteredItemLabel : filteredOptions[currentIndex];
      var optionIndex = getOptionIndex(selectedOption);
      var isDisabled = false;
      if (getOptionDisabled && typeof selectedOption === 'string') {
        isDisabled = getOptionDisabled(selectedOption, optionIndex);
      }
      if (!isDisabled) {
        setCurrentItemIndex(currentIndex);
        break;
      }
      if (direction === 'ArrowUp') {
        if (currentIndex === 0) {
          currentIndex = filteredOptions.length;
        }
        currentIndex -= 1;
      }
      if (direction === 'ArrowDown') {
        if (currentIndex === filteredOptions.length - 1) {
          currentIndex = -1;
        }
        currentIndex += 1;
      }
    }
  };
  var handleKeyDown = function handleKeyDown(event) {
    if (open) {
      if (event.key === 'ArrowUp') {
        if (currentItemIndex > 0) {
          getNextAvailableOption(currentItemIndex - 1, event.key);
        } else {
          getNextAvailableOption(filteredOptions.length - 1, event.key);
        }
      }
      if (event.key === 'ArrowDown') {
        if (currentItemIndex < filteredOptions.length - 1) {
          getNextAvailableOption(currentItemIndex + 1, event.key);
        } else {
          getNextAvailableOption(0, event.key);
        }
      }
      if (event.key === 'Enter' && currentItemIndex >= 0) {
        var selectedOption = filteredOptions[currentItemIndex];
        if (typeof selectedOption === 'string') {
          handleSelectedItem(event, selectedOption, -1, getOptionIndex(selectedOption));
        } else {
          handleSelectedItem(event, getNextOptionLabel(selectedOption), getNextOptionValue(selectedOption), getOptionIndex(getNextOptionLabel(selectedOption)));
        }
      }
      if (event.key === 'Escape') {
        handleCloseClick(event);
      }
    }
  };
  var getMultipleFilteredItems = function getMultipleFilteredItems(item, val) {
    if (isObjectOptions) {
      if (getOptionLabel ? convertToLower(getOptionLabel(item)).includes(convertToLower(val) || '') : convertToLower(item.label).includes(convertToLower(val) || '')) return true;
    } else if (convertToLower(item).includes(convertToLower(val) || '')) return true;
    return false;
  };
  var getMultipleFilteredOptions = function getMultipleFilteredOptions() {
    var filteredMenuOptions = [];
    if (isObjectOptions || multiple) {
      filteredMenuOptions = getFilteredItems(removedDuplicatedOptions, function (item) {
        return getMultipleFilteredItems(item, renderedValue);
      });
    } else {
      // filter menu options based on the value[0] as it's an array in multiple mode
      filteredMenuOptions = getFilteredItems(removedDuplicatedOptions, function (item) {
        return getMultipleFilteredItems(item, value[0] || '');
      });
    }
    setFilteredOptions(filteredMenuOptions);
  };
  var getFilteredOptions = function getFilteredOptions() {
    var filteredMenuOptions = removedDuplicatedOptions;
    if (isObjectOptions) {
      filteredMenuOptions = getFilteredItems(filteredMenuOptions, function (option) {
        var _convertToLower;
        return getOptionLabel ? (_convertToLower = convertToLower(getOptionLabel(option))) === null || _convertToLower === void 0 ? void 0 : _convertToLower.includes(convertToLower(renderedValue)) : convertToLower(option.label).includes(convertToLower(renderedValue));
      });
    } else if (value) {
      filteredMenuOptions = getFilteredItems(filteredMenuOptions, function (option) {
        return convertToLower(option).includes(convertToLower(value[0]));
      });
    }
    setFilteredOptions(filteredMenuOptions || []);
  };
  var isActiveMenuItem = function isActiveMenuItem(item, index, id) {
    if (item === selected || index === currentItemIndex || multiple && selected.includes(item) || isObjectOptions && Array.isArray(selected) && selected.includes(id) && selectedItemsIndex.includes(index) || isObjectOptions && selected === id && selectedItemsIndex.includes(index)) return true;
    return false;
  };
  var showMiActions = function showMiActions(item, id, index) {
    if (selected === id || item === selected || multiple && selected.includes(item) || isObjectOptions && selected.includes(id) && selectedItemsIndex.includes(index)) return true;
    return false;
  };
  var renderLabel = function renderLabel() {
    if (label) {
      if (typeof label === 'function') {
        return label({
          error: error
        });
      }
      if (_typeof(label) === 'object') {
        return label;
      }
      return /*#__PURE__*/React.createElement(Label, _extends({
        size: size,
        error: error
      }, LabelPropsData || {}), label);
    }
    return null;
  };
  var renderTags = function renderTags() {
    if (multiple && isItemSelected && Array.isArray(selected)) {
      return selectedItemsIndex.map(function (itemIndex, index) {
        var itemId = getNextOptionValue(removedDuplicatedOptions[itemIndex]);
        var item = isObjectOptions ? getObjectOptionLabel(itemId, itemIndex) : removedDuplicatedOptions[itemIndex];
        var title = isObjectOptions ? getObjectOptionLabel(itemId, itemIndex) : item;
        return /*#__PURE__*/React.createElement(Tag, {
          key: index,
          tagIndex: index,
          crossIcon: true,
          onRemove: function onRemove(_, event) {
            return handleOnRemoveItem(event, itemIndex, index);
          },
          title: title
        }, item);
      });
    }
  };
  var renderHint = function renderHint() {
    if (hint) {
      if (typeof hint === 'function') {
        return hint({
          error: error
        });
      }
      if (_typeof(hint) === 'object') {
        return hint;
      }
      return /*#__PURE__*/React.createElement(FormHint, {
        size: size,
        error: error
      }, hint);
    }
    return null;
  };
  var renderMenuItem = function renderMenuItem(item, index, id) {
    var optionIndex = getOptionIndex(item);
    var miActions = /*#__PURE__*/React.createElement(MenuItemActions, null, /*#__PURE__*/React.createElement(Styled.TickIcon, null, /*#__PURE__*/React.createElement(Tick, {
      size: 12
    })));
    return /*#__PURE__*/React.createElement(MenuItem, {
      key: optionIndex,
      value: item,
      size: size,
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      },
      noOptionsText: item === noOptionsText,
      disabled: getOptionDisabled && getOptionDisabled(item, optionIndex),
      active: isActiveMenuItem(item, index, id),
      onClick: function onClick(event) {
        return handleMenuItemClick(event, item, optionIndex, id);
      },
      enableScrollIntoView: true
    }, item, showMiActions(item, id, index) && miActions);
  };
  useEffect(function () {
    if (focusOnOpen) setAnchorEl(inputRef.current);
  }, [focusOnOpen]);
  useEffect(function () {
    if (isItemSelected) {
      filteredOptions.map(function (option, index) {
        if (option === selected) {
          setCurrentItemIndex(index);
        }
        return null;
      });
    }
  }, [anchorEl]);
  useEffect(function () {
    if (multiple) {
      getMultipleFilteredOptions();
    } else {
      getFilteredOptions();
    }
  }, [value, renderedValue, anchorEl]);
  useEffect(function () {
    if ((filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.length) === 0) {
      setFilteredOptions([noOptionsText]);
    }
  }, [filteredOptions, value]);
  useEffect(function () {
    setFilteredOptions(removedDuplicatedOptions);
  }, [options]);
  useEffect(function () {
    var filteredMenuOptions = isObjectOptions ? removedDuplicatedOptions.map(function (option) {
      return getNextOptionLabel(option);
    }) : removedDuplicatedOptions;
    if (multiple) {
      var nextOptionIndex = (value === null || value === void 0 ? void 0 : value.map(function (item) {
        return removedDuplicatedOptions.findIndex(function (option) {
          return getNextOptionValue(option) === item;
        });
      })) || [];
      var nextOptionId = nextOptionIndex.map(function (item) {
        return getNextOptionValue(removedDuplicatedOptions[item]);
      });
      setSelected(nextOptionId);
      setSelectedIemsIndex(nextOptionIndex);
    } else {
      var _nextOptionIndex = removedDuplicatedOptions.findIndex(function (option) {
        return getNextOptionValue(option) === value;
      });
      var _nextOptionId = getNextOptionValue(removedDuplicatedOptions[_nextOptionIndex]);
      if (_nextOptionIndex !== -1) setSelectedIemsIndex([_nextOptionIndex]);else setSelectedIemsIndex([]);
      setSelected(_nextOptionId || '');
    }
    if (!multiple && (value === null || value === void 0 ? void 0 : value.length) !== 0) {
      var valueOptionIndex = filteredMenuOptions.findIndex(function (option) {
        return option === value;
      });
      if (valueOptionIndex !== -1) {
        setCurrentItemIndex(valueOptionIndex);
        setSelected(value);
      }
    }
    if (hasDuplicatedLabels) {
      console.warn('options have duplicate Labels');
    }
  }, [value]);
  return /*#__PURE__*/React.createElement(Styled.Autocomplete, _extends({
    ref: ref
  }, rest), renderLabel(), /*#__PURE__*/React.createElement(Styled.AutocompleteContainer, {
    onClick: disabled || readOnly ? undefined : handleOpenClick
  }, /*#__PURE__*/React.createElement(Input, _extends({}, InputPropsData || {}, {
    ref: inputRef,
    size: size,
    value: getValue() || '',
    renderTags: renderTags,
    selectedItems: selected,
    readOnly: readOnly,
    error: error,
    focusOnMount: focusOnOpen,
    onKeyDown: handleKeyDown,
    onChange: handleInputChange,
    onBlur: onBlurHandler,
    disabled: disabled,
    placeholder: placeholder,
    fullWidth: fullWidth,
    isEllipsis: true,
    iconEnd: function iconEnd() {
      return /*#__PURE__*/React.createElement(ArrowTick, {
        onClick: disabled || readOnly ? undefined : handleOpenClick,
        type: open ? 'top' : 'bottom',
        IconProps: {
          size: size === Size.Md ? 11 : 10
        }
      });
    },
    clearIcon: isItemSelected && /*#__PURE__*/React.createElement(Styled.CrossIcon, {
      size: size === 'md' ? 11 : 10
    }),
    clearIconClick: handleClearIconClick
  }))), /*#__PURE__*/React.createElement(Menu, _extends({
    onClose: handleCloseClick,
    open: open,
    scroll: scroll,
    anchorEl: anchorEl,
    style: {
      maxHeight: '250px'
    }
  }, MenuProps), _typeof(filteredOptions[0]) === 'object' ? Object.values(filteredOptions).map(function (option, index) {
    return renderMenuItem(getNextOptionLabel(option), index, getNextOptionValue(option));
  }) : filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.map(function (item, index) {
    return renderMenuItem(item, index, null);
  })), renderHint());
});
Autocomplete.defaultProps = {
  size: InputSize.Md,
  multiple: false,
  disabled: false,
  scroll: true,
  readOnly: false
};
Autocomplete.propTypes = {
  children: PT.oneOfType([PT.element, PT.arrayOf(PT.element)]),
  size: PT.oneOf(objectValues(InputSize)),
  LabelProps: PT.exact(labelPropTypes),
  InputProps: PT.exact(inputPropTypes),
  value: PT.oneOfType([PT.string, PT.array]),
  label: PT.node,
  hint: PT.node,
  options: PT.array.isRequired,
  noOptionsText: PT.string,
  placeholder: PT.string,
  readOnly: PT.bool,
  fullWidth: PT.bool,
  multiple: PT.bool,
  disabled: PT.bool,
  scroll: PT.bool,
  focusOnOpen: PT.bool,
  error: PT.bool,
  onChange: PT.func,
  onOpen: PT.func,
  onClose: PT.func,
  getOptionDisabled: PT.func,
  getOptionValue: PT.func,
  getOptionLabel: PT.func,
  submitOnBlur: PT.func
};
export default Autocomplete;